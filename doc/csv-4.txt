==========================
CSV ファイルの処理方法 - 4
==========================
CSV はデータが単に羅列されたものですから、何番目のフィールドがどのような意味を持つかを教えてあげる必要があります。
各フィールドの意味は、別の仕様書に記述されている場合と、ファイルの先頭ヘッダーに記述されている場合があります。

ここでは前者を扱います。

データの並びがあらかじめ分かっている場合
========================================
次のような CSV ファイルを考えます。

    ==============  ======================
    フィールド番号  意味
    ==============  ======================
    1               順位
    2               チーム
    3               勝点
    4               試合
    5               得失点差
    ==============  ======================

:file:`csv-4.csv`

.. literalinclude:: ../etc/csv-4.csv

辞書データに変換
----------------
データの並びに意味をマップさせるには、 ``zip()`` と ``dict()`` を組み合わせることで実現できます。

:file:`csv-4.py`

.. literalinclude:: ../src/csv-4.py
   :language: python

なお、辞書の値だけを取り出すには ``values()`` メソッドも使えます。
キーだけを取り出すには ``keys()`` を使います。

オブジェクトに変換
------------------
クラスを定義して、コンストラクタに渡す方法もあります。
タプルに "*" 記号を付けると、引数には展開されて渡されます。
(そういう書き方もあるよ、というレベルの話で、多用しないでください)

オブジェクトに変換する場合には型をチェックしても良いでしょう。
値の制約条件をチェックするのも有効です。

:file:`csv-4a.py`

.. literalinclude:: ../src/csv-4a.py
   :language: python

クラスを定義するときは ``self`` というキーワードが欠かせません。
メソッド内で使う場合も使わない場合も記述しなければなりませんが、
``self`` を使う必要のないメソッドは、そもそもそのクラスに定義すべきメソッドではないかもしれません。
Python はトップレベルに関数を定義できますので、無理にクラスを定義する必要はないことを忘れないでください。

``self`` の必要性について考えるためには ``@classmethod`` 、 ``@staticmethod`` 、デコレータの実装方法について学習しなければなりません。
詳しく知りたい場合はこちらのブログを読んでから、再度考えてください。

* `Why explicit self has to stay`_ (`和訳 : なぜPythonのメソッド引数に明示的にselfと書くのか`_)

.. _Why explicit self has to stay: http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html
.. _`和訳 : なぜPythonのメソッド引数に明示的にselfと書くのか`: http://coreblog.org/ats/translation-of-why-explicit-self-has-to-stay

宿題
====
オプションを変更することで挙動を切り替え可能にしましょう。

* 出力データの区切り文字
* 出力先 (標準出力とファイル)
* 入力の文字エンコーディングと出力の文字エンコーディング

ここまでは設定だけで使ってきませんでしたが、 `logging` モジュールを使ってログを出力できます。
処理している行数を *INFO* レベルで出力するようにスクリプトを修正してみましょう。
